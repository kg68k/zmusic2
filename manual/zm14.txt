
	    ＭＥＡＳＵＲＥ１４
      効果音モードと映像同期モード


  ここでは、ＺＭＵＳＩＣの特殊機能である

「効果音モード」と「映像同期モード」についての

解説を行います。本章を理解するには

ＭＰＵ６８０００の機械語の知識が必要です。

通常の音楽演奏のみを行なうユーザーは読み飛ばして

構いません。

  「効果音モード」の解説はオリジナル・ゲーム・

プログラムで実際に使用することを想定して

具体的に解説します。








１４．１．  効果音モード


１４．１．１．  ＺＭＵＳＩＣの組み込み


●組み込みメッセージの制御

－Ｇ

  ＺＭＵＳＩＣを組み込んだ後にＺＭＵＳＩＣのロゴやバージョン番号、確保した

バッファの容量等の情報が画面に出力される。このスイッチを設定するとこれらを

いっさい表示しないようにすることができる。機能自体に特別な深い意味はないが

アプリケーションを起動する際の画面バランスに気を使う場合は設定するとよい。


●多重割り込みに対応させる

－Ｍ

  ゲームのメインプログラムでラスタースクロールやその他のＭＦＰを使った割り込みを

使用している場合には設定したほうがよい。設定しないとＺＭＵＳＩＣの割り込み

処理中に一切の割り込みがキャンセルされてしまい、希望通りの処理がなされない

場合がある。

  しかしこのモードでＭＦＰを使った割り込み処理が極端に重くなった場合は、

音楽側のテンポに影響が出ることがある。

  ＰＣＭ８モード時には暗黙のうちにこのモードが選択される。

●初期化制御

－Ｎ

  ＺＭＵＳＩＣでは通常、新たに演奏データを演奏しようとするとＭＩＤＩ楽器に

初期化パラメータを設定したりＦＭ音源の初期化等をしている。この初期化処理は

新たに演奏する曲の都合を無視したものである。たとえばＭＩＤＩ音源の10チャンネル

以下しか使用していない曲をこれから演奏しようという時に11チャンネル以上の

初期化も行ってしまう。この「余計な処理」はゲームの曲の切り替え時において

ゲーム画面のスクロールの一時停止といった目に見える症状になってしまう場合がある。

そこでこの'－Ｎ’オプションスイッチを設定すると以後この「余計な処理」処理を

省くことができる。ただしＦＭ音源／ＭＩＤＩ楽器に対して一切の初期化処理を

行わなくなるので各演奏データには必要な初期化データを盛り込む必要が

出てくる（後述）。


┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃				２通りの演奏データ形式				┃
┃										┃
┃  ゲームの演奏データを設計する場合に二通りのバリエーションが存在する。	┃
┃										┃
┃  １つはＭＩＤＩ対応曲と内蔵音源対応曲を分けてそれぞれ用意する場合（Ｏｈ！Ｘ	┃
┃										┃
┃１９９２年６月号付録の「ＳＩＯＮII」やコナミの「出たな!!ツインビー」など）。	┃
┃										┃
┃  もう１つは内蔵音源がメインでＭＩＤＩボードがある場合はＭＩＤＩ音源もこれに	┃
┃										┃
┃重なって鳴るといった、１つのデータで両方をまかなうタイプのもの（コナミの	┃
┃										┃
┃「パロディウスだ!!」など）。							┃
┃										┃
┃  ＺＭＵＳＩＣでは常駐処理の時にＭＩＤＩボードの有無を検査してＭＩＤＩボードが┃
┃										┃
┃なければ以後、ＭＩＤＩ部の演奏を自動的にミュートして内蔵音源部のみ演奏出来る	┃
┃										┃
┃モードになる。								┃
┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛


●汎用ワークエリアの設定

－Ｗn

  ゲーム等の曲で演奏のたびにＡＤＰＣＭコンフィギュレーションファイルを読んだり

ＡＤＰＣＭの加工処理を行ったりするのはまったくの非常識であるため汎用ワークは

不要ということになる。よって普通は

－Ｗ0

でいいことになる。


●ＡＤＰＣＭデータ

－Ｂ ＺＰＤファイルネーム

－Ｐn

  ゲーム中に用いるすべてのＢＧＭが１つのＺＰＤデータを用いてる場合は

－Ｂ  ＺＰＤファイルネーム

でドライバ組み込み時に組み込んでしまうとよい。'－Ｂ'は組み込むＺＰＤファイルの

ファイルサイズ分自動的にＡＤＰＣＭバッファを確保してくれるため便利である。

  ゲーム中に数回ＺＰＤデータを切り替えたりする場合は'－Ｐ'で必要最大分バッファを

確保して、あとからファンクションコールなどを使ってＺＰＤデータや

ＡＤＰＣＭデータを登録するということになる。

  また、演奏する曲がまったくＡＤＰＣＭを使用しない場合はＡＤＰＣＭバッファを

特に確保する必要はない。


●トラックバッファ

－Ｔn

  曲データをゲームプログラム開始前に一括してメインプログラムの管理領域に

読み込んでしまうのが賢明である。そして曲の切り替え時にはあらかじめ

読み込んでおいた演奏データの先頭アドレスをＺＭＵＳＩＣに与えてやればよいので

ある（具体例は後述）。ということはつまりＺＭＵＳＩＣのトラックバッファは

まったく不要ということであるから、その場合

－Ｔ0

でよいことになる。

  また、ゲームのメインプログラムが大きくて一括して読み込めない場合は

1ステージ内に必要分を先読みするようにすればよい(例ステージＢＧＭ、ボスＢＧＭ)。


１４．１．２．  ゲームに負担をかけない演奏データとは？


  まず、演奏データ制作者はゲームのプログラムに負担をかけないように心掛けて

演奏データを作成しなければならない。また、曲の切り替りに時間がかからない様に

しなければならない。例えばスクロールシューティングゲームでステージＢＧＭから

ボスのテーマに切り替る時に、スクロールが止まってしまってはスピード感を損ねて

しまう。

  したがって曲データはすべて応答の高速であるＺＭＤレベルで管理すべきである。

さもないと曲の切り替るたびにコンパイルする動作を強いられ、曲の切り替えが

とても遅くなるからである。

  ここでは曲の切り替りの早い演奏データを作るためのテクニックについてのべる。



●共通コマンドは使わない

  ＦＭ音源音色の定義コマンドやＭＩＤＩエクスクルーシブコマンドなどのトラックに

依存しない、いわゆる「共通コマンド」は割り込みで処理されないために

曲の切り替え時のウェイトになりかねない。つまりＺＭＳファイルをコンパイルして

ＺＭＤを得た時に共通コマンド部分のＺＭＤコードが皆無ならばよいのである。

  そこでＭＭＬで簡単に置き換えられる共通コマンドはすべてＭＭＬに置き換えた

ほうがよい。たとえばテンポ設定ＺＭＳコマンド(Ｏn)は用いずＭＭＬの

テンポコマンドを用いるようにしたり、'.ROLAND_EXCLUSIVE'命令や

'(Ｘn 1,n 2,n 3,…,n i)'などはＸコマンドや、＠Ｘコマンドを用いたりしてＭＭＬへ

直していく。

  また、どうしても置き換わらないもの

	     音色登録

	     ＭＩＤＩ楽器個別コマンド

などは後述する方法で解決する。

  結局ゲームに用いる演奏データには

初期化コマンド…(Ｉ)

ベースチャンネル設定…(Ｂn)

トラック確保…(Ｍtr,size)

チャンネルアサイン…(Ａch,tr)

以外の共通コマンドを用いないようにする。以上の４つのコマンドはコンパイル時に

消化され、共通コマンドコードとしてＺＭＤデータに生成されない。


●音色登録

  演奏データには様々な音色が使用されるが、この音色データを１曲ごとに持たせて

演奏の開始時にいちいち登録していたのでは曲の切り替りが遅くなってしまう

（アクションゲームのような極端な高速切り替えが要求されていないＲＰＧやＡＤＶなら

別に構わないであろうが）。

  ＺＭＵＳＩＣではＦＭ音源200音色分(No.1～No.200)の専用バッファを持っており、

ドライバが解除されたりしなければ、この領域はいつまでも保存されている。よって、

そのゲーム中に使用されるＦＭ音色をあらかじめドライバの組み込み時に

オプションスイッチ'－Ｓ'で転送してしまい演奏データには一切のＦＭ音色データを

持たないようにすればよい。効果音で用いられるＦＭ音色も一緒に送ってしまうと

よい。

  ＭＩＤＩ楽器の音色の場合もＦＭ音源音色の場合と同様である。そのゲーム中の

ＢＧＭで使用する音色データをＭＩＤＩ楽器へあらかじめ登録してしまえばよいの

である(ＭＩＤＩ楽器の初期化コマンドを実行すると設定した音色までも初期化される

事があるので注意)。

  音色のセットアップファイルの例をリスト１に示す。このリスト１のようなものを

A>zmusic  －sSETUP.ZMS

のようにしてドライバ常駐とともに組み込んでしまえばよいのである。

  もちろんコンパイルして

A>zmusic －sSETUP.ZMD

の様にしても構わない。

  複数のＭＩＤＩ楽器に対応している場合はＭＵＳＩＣコンフィギュレーションの

ような場所で楽器を選ばせ、その時点であらかじめ用意しておいたその楽器の

音色データをセレクトして転送するようにすればよいであろう。


●ＭＩＤＩ楽器個別コマンド

  音色データやグローバルなＭＩＤＩ楽器の設定はゲームが開始される前にあらかじめ

登録しておくことで解決するが、１曲ごとに変えたい設定もある。たとえばパーシャル

リザーブなどである。

  楽器個別命令も共通コマンドであるためなんとかＭＭＬへコンバートしたいところで

ある。こういったものはエクスクルーシブメッセージで処理を実現しているため

ＭＭＬの＠ＸやＸへ変換できなくはないが、いちいち楽器のマニュアルを見ながら

ＭＭＬを書いていくのは大変である。

  こういう場合には同梱の支援ツール「ＺＭＤ１８．Ｒ」を使用するとよい。

  このＺＭＤ１８．ＲはＺＭＤデータ中にあるＭＩＤＩ楽器個別コマンドを

ＭＭＬに変換するものである。

  具体的な使い方を以下に示す。

  たとえばＭＵＳＩＣ．ＺＭＳというＭＩＤＩ楽器個別コマンドが多用された

ＺＭＳファイルがあったとする。これを

A>zmusic -c MUSIC

としてコンパイルし、ＭＵＳＩＣ．ＺＭＤを得る。

  つぎに

A>zmd18 MUSIC

とすると画面に

(T1)@X$F0,$41,$10,$16,$12,$7F,$00,$00,$00,$01,$F7
(T1)@X$F0,$41,$10,$16,$12,$08,$00,$00,$43,$48,$4F,$52,$44,$20,$20,$20
(T1)@X$20,$20,$00,$00,$03,$00,$24,$35,$0B,$01,$02,$00,$24,$09,$00,$00
(T1)@X$00,$00,$00,$00,$00,$32,$32,$32,$32,$32,$3E,$17,$55,$64,$17,$04
(T1)@X$27,$08,$18,$64,$00,$00,$00,$0D,$18,$4D,$53,$64,$59,$4C,$48,$5E
(T1)@X$4A,$5B,$0C,$1B,$0C,$00,$00,$00,$00,$00,$09,$2B,$64,$64,$64,$63
(T1)@X$24,$30,$0B,$01,$03,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$32
(T1)@X$32,$32,$32,$32,$40,$17,$38,$64,$17,$05,$67,$06,$2B,$64,$00,$00
(T1)@X$00,$07,$16,$64,$62,$64,$5E,$54,$4F,$5E,$46,$5B,$0C,$1B,$0C,$00
(T1)@X$00,$00,$04,$0B,$0E,$0F,$64,$60,$5C,$5B,$6B,$F7
(T1)@X$F0,$41,$10,$42,....
(T1)@X.....
     ：
     ：

といったものが出てくる。これらがＺＭＤ中のＭＩＤＩ楽器個別コマンドが

ＭＭＬへとコンバートされたものである。

  これをリダイレクトしてどこかに保存し、ＭＵＳＩＣ．ＺＭＳのトラック１の先頭へ

挿入する。また、ＥＯＸ($F7)の後には若干のウェイトが必要なので休符を

添付してやる。あとは、ＭＵＳＩＣ．ＺＭＳ中の共通コマンドを全て削除すれば作業の

終わりである。


●コメント

  演奏データのタイトルや作者名を記述するのに使われている.comment文も演奏時には

文字列をスキップする動作を強いられるため、これがウェイトになりかねないので

用いないようにする。


●テンポ

  曲のテンポは共通コマンド(Ｏn)を用いずにＭＭＬのＴコマンドを用いて

変化させたほうがいいということは、すでに述べた通りである。

  ゲーム中に用いる曲の場合、テンポがステージ毎にあまりにも速かったり遅かったり

すると効果音もそのテンポにつられて速くなったり遅くなったりする。例えばある

ステージでＢＧＭがテンポ100で演奏されていてレーザーの発射音が

「ちゅーーん・ちゅーーん」だったとする。そして別のステージに突入し、

ＢＧＭのテンポが倍の200になったとすると「ちゅん・ちゅん」になってしまう。

  これを防止（というかつじつまを合せる）するのが(Ｚn)コマンドである。

この命令は全音符の絶対音長をデフォルトの192からnへ変更するものである。

  テンポが速くなるというのはタイマ割り込みの割り込み間隔が速くなるという

ことであるから、この割り込み間隔を一定にしつつ曲のテンポを変えることを

考えればいいのである。

  先程のＢＧＭのテンポが速くなったために効果音も速く鳴ってしまった例は、

(効果音と、もとのＢＧＭが全音符の絶対音長が192基準で作られているならば)、

テンポ200の曲の方を全音符の絶対音長を96にしてやれば、テンポ200でも

割り込み間隔はテンポ100と全く同じものとなり、この曲はテンポ200、

効果音はテンポ100で演奏され万事解決となる。

  つまりタイマ値を大体一定（あんまり厳密でなくて構わないが）にし、

ひとつのひとつの音符の絶対音長の長短でテンポを調整するイメージである。

テンポＭＭＬコマンドＴはこの全音符の絶対音長変更コマンドの(Ｚn)を考慮して

タイマ値を算出してしまうのでタイマ値を直接設定できる＠Ｔコマンドを用いると

分かりやすいであろう。

  ところでこの(Ｚn)コマンドは共通コマンドであるからＺＭＤデータとしても

生成されてしまう。共通コマンドの削減をこれまで繰り返し言ってきたが、

このコマンドは実行に大して時間を食わないので、例外として扱って構わないだろう。


●初期化

  前節で解説したようにＺＭＵＳＩＣを'－Ｎ'オプションを付けて初期化なしモードで

常駐させている場合、各演奏データに楽器初期化等のコマンドを盛り込まないと前の

演奏データの設定状態が受け継がれることになってしまう。

  ＺＭＵＳＩＣでは初期化モードでない通常モードの場合、新たな演奏データの

演奏開始直前に以下のようなメッセージを送信している。

ＦＭ音源部

ノイズモードオフ(Ｙ15,0相当)

ＡＤＰＣＭ音源

特になし。

ＭＩＤＩ音源部

リセット　オール　コントローラーズ($Bn,$79,$00)

オムニ  モード  オン($Bn,$7D,$00)

モノ  モード  オフ($Bn,$7F,$00)

ローカル  オン($Bn,$7A,$7F)

ファインチューニングをニュートラルへ($Bn,$65,$00,$Bn,$64,$01,
				     $Bn,$06,$40,$Bn,$26,$00)

コースチューニングをニュートラルへ($Bn,$65,$00,$Bn,$64,$02,$Bn,$06,$40)

ピッチ・ベンドレンジ＝１オクターブ($Bn,$65,$00,$Bn,$64,$00,$Bn,$06,$0C)

ボリューム＝63($Bn,$07,$3F)

パンポット＝中央($Bn,$0A,$40))

ピッチ・モジュレーション＝0($Bn,$01,$00)

ダンパー  オフ($Bn,$40,00)

ピッチ・ベンドをニュートラルへ($En,$00,$40)

  以上から必要なものをピックアップして演奏データに盛り込むべきである。

初期化なしモードとそうでない場合の違いはこれらの初期化動作が行われるか、

行われないかの違いになってくる。こうしてみるとＦＭ音源とＡＤＰＣＭ音源は

初期化なしモードと通常モードの区別を特に意識する必要はないかもしれない。

  演奏データをゲームプログラムなどに取り込む前に一度、初期化なしモードで

演奏してみるとよいだろう。それで演奏がおかしかったならば、どの初期化メッセージ

が足りなかったのかを見極めて、随時それらを盛り込んでいくとよいだろう。

  ローランド系のＤＴＭ楽器（ＣＭやＭＴ、ＳＣシリーズなど）では楽器の

メモリアドレスのある箇所にダミーデータを書き込むと本体内の全パートを

初期化してくれる便利な機能がある。これを使えば上のような初期化メッセージを

いちいち送らなくても少ない手間で初期化が行える。いくつか例を挙げておく。

（初期化したあとの楽器の状態については各楽器のマニュアルを参照し確認すること）


●ＭＴ３２/ＣＭ３２Ｌ/ＣＭ６４/ＣＭ３２Ｐ/ＣＭ５００のＬＡ音源部
$7F,$00,$00にダミーデータを書き込む
例
  共通コマンド….ROLAND_EXCLUSIVE $10,$16＝{$7F,$00,$00,$00}
  ＭＭＬ…@I$41,$10,$16 X$7F,$00,$00,$00


●ＳＣ５５/ＳＣ１５５/ＣＭ３００/ＣＭ５００のＧＳ音源部
$40,$00,$7Fにダミーデータを書き込む
例
  共通コマンド….ROLAND_EXCLUSIVE $10,$42＝{$40,$00,$7F,$00}
  ＭＭＬ…@I$41,$10,$42 X$40,$00,$7F,$00
  (ＳＣ５５は初期化するとベンドレンジが２半音範囲になってしまう点に注意すること)

┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃                              ＣＯＭＣＨＫ．Ｒ                              ┃
┃                                                                            ┃
┃                                                                            ┃
┃  開発途中はいろいろと曲のデータの方も日に日に手を入れられ改良されていく    ┃
┃                                                                            ┃
┃でしょうから、共通コマンドを撲滅するのは最終的な段階で構わないでしょう。 　 ┃
┃                                                                            ┃
┃  そこで最終的なチェック用としてコンパイルして生成したＺＭＤデータに        ┃
┃                                                                            ┃
┃共通コマンドがあるかないかを検査するプログラム「ＣＯＭＣＨＫ．Ｒ」を        ┃
┃                                                                            ┃
┃提供します。                                                                ┃
┃                                                                            ┃
┃  使い方は                                                                  ┃
┃                                                                            ┃
┃ＣＯＭＣＨＫ  ＺＭＤファイル                                                ┃
┃                                                                            ┃
┃とするだけです。共通コマンドがあれば「ある」と、なければ「ない」という結果を┃
┃                                                                            ┃
┃出力してくれます。                                                          ┃
┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛


１４．１．３．  ＢＧＭデータの改変具体例


  ここでは、いままで解説してきた事柄を実際の音楽プログラムに対して行ってみる

ことにしよう。

  リスト２のようなミュージックプログラムがあったとしてこれをゲーム向きの

データへ修正していくとする。

  まず、コンパイルをしてＺＭＤを得る。

A>zmusic -c LIST2

  このＺＭＤデータに対してＺＭＤ１８．Ｒを実行しリダイレクトして

共通コマンド部分をＭＭＬに変換する。

A>zmd18 LIST2 > LIST3

  リスト３のようなものが得られる。再びリスト２を読み込んで上から順番に

共通コマンドをつぶしていく。まず１番上の.comment文を'／'に置き換えて無効化

する。そこから下にみていくと、テンポコマンドがあるがこれを無効化しＭＭＬに直す。

  その下のＭＩＤＩ楽器個別コマンドを'／'で無効化する。ちょうどこれらの

共通コマンドの働きと同じものがＺＭＤ１８．Ｒによって生成されたリスト３である。

  このリスト３をリスト２のＭＭＬ部分の先頭に挿入する。前述のようにＥＯＸ($F7)の

あとには多少のウェイトが必要であるから、休符'r16'を２つあるＥＯＸの後ろに

挿入する。このままでは１トラックだけr16×2＝r8分演奏が遅れてしまうため他の

トラックにつじつま合せを施す。

  こうしてできたのがリスト４でこれをコンパイルすれば共通コマンドなしの

ＺＭＤの完成となる。


１４．１．４．  演奏開始ルーチン


  できた曲データ(ＺＭＤ)をゲームのメインプログラムから演奏するためには、

ＺＭＵＳＩＣを呼び出すための簡単なマネージメント・プログラム(つまりは

演奏開始ルーチン)が必要である。さまざまな演奏開始ルーチンが考えられるが

サンプルとしてリスト５を示す。

  この例では各演奏データがmusic0、music1、music2…とそれぞれ偶数番地に

読み込まれているとする。そこでmusic0を演奏したいならばd0.lに0、music1を

演奏したいならばd0.lに1を入れ、このルーチンplay_musicをサブルーチンコールする

ようにする。これで演奏が開始される。

  演奏データに埋め込まれているドライバのバージョンＩＤをa1レジスタが

指標していなければならないというファンクション$11の仕様から、演奏データの

格納アドレスa1に7を足している。詳しくはファンクション$11の解説を参照。


１４．１．５．  効果音データの作成とその活用方法


  ゲームのＢＧＭに重ねて効果音を鳴らす場合はその演奏データのトラックと

チャンネルのアサイン関係をしっかり把握していなければならない。演奏データの

プログラマと効果音データのプログラマが異なる場合には、データ仕様を事前に

打ち合わせをしておくことをお勧めする。


●効果音データの制約

  効果音データも基本的にはＢＧＭデータと同じようにＺＭＳファイルを

コンパイルしたＺＭＤで表現される。しかし、ＢＧＭデータとの大きな違いは

１．共通コマンドを持てない

２．効果音用の演奏トラックワークには初期値がない

３．以下のＭＭＬコマンドを使用した時の動作が保証されない

・［］系コマンド([DO]～[LOOP]は使用可)

・ 和音コマンド

  効果音の演奏制御は、高速応答を要求されるのでパラメータの有効範囲チェック等は

いっさい行っていない。不当なパラメータで関連ファンクションをコールした場合は

暴走する危険性がある。また、２．にもある通りワークの初期化も行わないため

ディチューンやボリューム等の基本パラメータの初期値も不定である。よって必ず

設定すること。

  また、効果音にＭＭＬのテンポコマンドを用いることは禁止していないが、

その効果音が鳴るたびにＢＧＭのテンポが変化してしまうため使用しない方がよい。

  効果音データの実例をリスト６に示す。音色データはすでに述べたように事前に

登録してあるものとする。これをコンパイルして得たＺＭＤをダンプデータに

変換したものがリスト７である。ＺＭＤにはヘッダ'ZmuSiC'などが付くが、これは

まったく不要であるため取ってしまう(残しておいても構わないがメモリのムダに

なるので)。そしてリスト７の10バイト以降をアセンブラのソース・プログラム形式に

変換してやるとリスト８のようなものになる。

  リスト９のように複数トラックの効果音データも作成可能である。これを

コンパイルし同様に変換してやるとリスト１０のようになる。


●効果音の演奏における２つの形式

  効果音を鳴らす場合には２通りの形式が存在する。

  １つは効果音が鳴るチャンネルをあらかじめ空けておく形式である。つまり効果音が

鳴るチャンネルをあらかじめ決めておいてＢＧＭデータを作成するわけである。

たとえばＦＭ音源の１チャンネルから７チャンネルまでをＢＧＭ専用チャンネルとし、

８チャンネル目を効果音チャンネルと割り当てる、といった場合である。

  ２つ目はＢＧＭを演奏しているチャンネルに割り込んで効果音を演奏する形式である。

たとえばＦＭ音源の１から８チャンネルすべてのチャンネルでＢＧＭを演奏し、

そのうち８チャンネルが効果音に切り換わったりする、といった場合である。この場合、

効果音が頻繁に演奏されると８チャンネル目はほとんど効果音しか鳴らなくなり

ＢＧＭの一声が欠けて聞こえることになる。よってＢＧＭの設計をする際に、

効果音が被ってくるチャンネルにはメロディやベース等の重要なパートを割り当て

ないようにすべきである。


●１番目の形式

  リスト１１は効果音のマネージメント・プログラムの一例である（リスト１１中の

サンプル効果音は、それぞれリスト８、リスト１０とまったく同じもの)。

  se_play1を見てほしい。

  トラック１から６までをＦＭ音源１チャンネルから６チャンネルに割り当てて

これをＢＧＭで使用し、ＦＭ音源７～８チャンネルを効果音として使用する場合を

考える。たとえばd0.lに効果音番号0をいれてse_play1を呼ぶと、トラック７番から

ＦＭ音源第７チャンネルでse0のデータが演奏される。se_play1中の

  moveq.l #7,d2

というのは、何番トラックで効果音を演奏するかを設定している。いま、

トラック１～６まででＢＧＭを演奏しているのでトラック７は未使用である。よって

何にもジャマされずごく普通に演奏がなされる。

  なぜこの例で効果音se0がＦＭ音源第７チャンネルで演奏されるかというと、それは

se0の効果音データに演奏絶対チャンネル番号が６(0～7のうちの6)というのが

埋め込まれているからである(囲み参照)。

  同様の条件で、se1を鳴らす場合も同様である。se1は複数トラックによって

構成された効果音データである。

  moveq.l #7,d2

とあるためトラック７から演奏するのである。まず、se1の第１トラックはd2.lで

指定した通りトラック７で演奏される。次にse1の第２トラックはd2.lで指定した

トラック番号＋１のトラック８で演奏される。

  このように複数トラックで構成された効果音は、d2.lで指定したトラック番号から

順番にトラックが割り当てられ演奏される。


●２番目の形式

  では今度はトラック１～８がＦＭ音源１～８チャンネルにアサインされＢＧＭが

演奏されていたとして、これに効果音を鳴らす場合を考える。こちらは前節で解説した

２番目の形式である。

  se_play1は結論からいえばこのままこの形式に対応できる。単一トラックのse0も

複数トラック構成のse1にも対応できる。正しく効果音が鳴っている間は、その

チャンネルはＢＧＭ演奏を中断し、効果音を演奏し、演奏が終了すると何事も

なかったようにそのチャンネルのＢＧＭ演奏を再開する。

  では

  moveq.l #7,d2

を

  moveq.l #1,d2

にしてse0を鳴らしたとしたらどうなるであろうか。つまりse0がＢＧＭの

トラック１から割り込むという場合である。

  たしかにＢＧＭのトラック１（ＦＭ音源第１チャンネル）の演奏が中断されるが、

効果音se0はＦＭ音源第７チャンネルで演奏されることになっているので、その

チャンネルで効果音を演奏しようとすると、ＢＧＭ側のＦＭ音源第７チャンネルに

アサインされたトラック７がＦＭ音源第７チャンネルをアクセスしてくる。言い換えると

複数の違った演奏データを同時にたった１個のＦＭ音源チャンネルで演奏しようする

状況が起こるわけである。そこで効果音、ＢＧＭ、ともに演奏が異常状態に陥る。

  se1は２本のトラックで構成された効果音であるがこの２本目のトラックが

ＦＭ１チャンネルに割当てられていたとする。つまりse1の上から５段目が$00,$07で

なくて$00,$00となっている場合である。これを

  moveq.l #7,d2

で７トラックから割り込ませるとする。

  さて実行されるとＢＧＭのトラック７に、ＦＭ音源第７チャンネルにアサインされた

se1の第１トラックが割り込んでくる。以後ＦＭ第７チャンネルは効果音を演奏する。

ＦＭ音源第７チャンネルにアサインされたＢＧＭ側のトラックは効果音に占領されて

いるトラック７しかないので、どのトラックからも効果音演奏を妨害されず

うまくいく。

  そしてつぎにＢＧＭ側のトラック８に、ＦＭ音源第１チャンネルにアサインされた

se1の第２トラックが割り込んでくる。ＢＧＭ側のトラック８はそれまでＦＭ音源

第８チャンネルで演奏していたＢＧＭを中断しＦＭ音源第１チャンネルで効果音を

演奏し始める。しかしその後、ＢＧＭ側のトラック１がＦＭ音源第１チャンネルを

アクセスしてくるのでおかしなことになってくる。

  つまりse1の第１トラックは正常に演奏されるが、第２トラックは正常に演奏されない

のである。

  つまりこの「効果音トラックがＢＧＭ演奏に割り込む」形式ではひとつ大前提が

あるのである。これから演奏する効果音のチャンネルが、割り込むトラックに

アサインされているチャンネルと同一でなければならないのである。

  この部分はたいへん重要である。

  以上の話を図式化したものを図１に示す。


┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃                                絶対チャンネル                          ┃
┃                                                                        ┃
┃                                                                        ┃
┃  内部表現の絶対チャンネルはベースチャンネルに無関係に操作対象デバイスを┃
┃                                                                        ┃
┃決定するものです。							  ┃
┃                                                                        ┃
┃絶対チャンネル０～７がＦＭ音源の１～８、絶対チャンネル８がＡＤＰＣＭ１、┃
┃                                                                        ┃
┃絶対チャンネル９～２４がＭＩＤＩ１～１６。そしてＰＣＭ８独立チャンネル  ┃
┃                                                                        ┃
┃モード時には絶対チャンネル２５～３１がＡＤＰＣＭ２～８に対応します。    ┃
┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛


●その他の応用

  効果音データはその演奏絶対チャンネルを持っていた。だから同じ効果音を違った

チャンネルで鳴らすためには、その絶対チャンネルの違ったデータを別に持たなければ

ならないのであろうか。それでも構わないが、メモリを浪費するので、効果音データの

その絶対チャンネルが書かれている部分を書き替えてひとつの効果音データを流用した

方が賢明である。

  リスト１１のse_play2はその一例である。パラメータは効果音番号と演奏チャンネル

の２つ。効果音データのアドレスを得たあと、そのアドレス＋7に演奏させたい

絶対チャンネルを書き込んでいる。効果音が複数トラックで構成されている場合は、

例えばse1ならば(効果音データのアドレス＋7)の他に(効果音データのアドレス＋13)

にも絶対チャンネルを設定しなければならない。

  se_play2では割り込むトラックはその絶対チャンネル＋1の値にしている。これは

ＢＧＭのトラック１～８がＦＭ音源の第１チャンネルから第８チャンネル

(絶対チャンネルにして０～７)にアサインされていることを前提としている。

  se_play3はse_play2を少し改良したものである。これは効果音をＦＭ音源

第７チャンネルと第８チャンネルを交互に用いて鳴らす処理を付けてみたものである。

こちらもＢＧＭのトラック１～８がＦＭ音源の第１チャンネルから第８チャンネル

(絶対チャンネルにして０～７)にアサインされていることを前提としている。

  こういった、状況に応じて効果音データを書き替えるような処理を工夫すると、

様々な効果を実現可能である。３Ｄのゲームならば効果音データのパンポットを、

その３次元座標に合せて書き替えて、疑似立体音響を実現させることも可能だろう。


●ＭＩＤＩ対応曲にＦＭの効果音

  今まではＦＭ音源のＢＧＭにＦＭ音源の効果音を割り込ませる話だったがＭＩＤＩ

対応の曲にＦＭ音源の効果音を割り込ませるにはどうしたらよいのかを解説する。

  ＢＧＭをＭＩＤＩで、効果音はＦＭ音源で、という場合は各音源の目的が既に

区別されているので、効果音の使用チャンネルがＢＧＭの使用チャンネルと

かち合わないため、前述の形式１のように実現できる。たとえばトラック1～16

までをＭＩＤＩでＢＧＭに使用している場合なら、効果音は未使用トラックである

トラック17以降に割り込ませれば（割り込んではいないが）よいことになる。

この方式は分かりやすく管理もしやすい。

  では、ＦＭ音源＋ＭＩＤＩ楽器でＢＧＭを、そしてＦＭ音源で効果音を、という

場合はどうであろうか。複雑そうだがこれは結局ＦＭ音源のみのＢＧＭにＦＭ音源の

効果音を割り込ませた方法がほとんどそのまま使える。

  たとえばＦＭ音源の第１チャンネルから第６チャンネルにアサインした

トラック１～６、そしてＭＩＤＩにアサインしたトラック7～12でＢＧＭを

演奏していたとする。つまりＦＭ音源第７，８チャンネルは未使用という時に、

この空いている２つのチャンネルを使って効果音を鳴らす場合を考える。これは

チャンネルがまったくかち合わないことから未使用トラックで効果音を鳴らせば

よいので前述の形式１がそのまま適用できる。よって効果音はトラック13以降へ

割り込ませてやれば（割り込んではいないが）よいことになる。

  最後にＦＭ音源第１チャンネルから第８チャンネルまでをトラック１～８に

アサインし、ＭＩＤＩをトラック9～16にアサインし、これでＢＧＭ演奏して、

これにＦＭ音源の効果音を割り込ませる場合を考える。ＦＭ音源の効果音はＭＩＤＩに

対して何の影響も与えないことからトラック9～16を除外して考えていいわけで

あるから、そうなると話はまったく前述の形式２と同じになってくる。つまり、

効果音をＦＭ音源第８チャンネルで演奏するならトラック８に割り込ませればいい

ことになる。


●ＭＩＤＩの効果音

  ＭＩＤＩで効果音を鳴らす場合にはもっと話が単純化する。ただＭＩＤＩチャンネル

というものは単一チャンネルでもＦＭ音源チャンネルでいう複数分として動作するから、

一つのＭＩＤＩチャンネルに対して複数のトラックをアサインするケースが頻繁に

出てくる。というわけで前述の形式１，２とも大した区別はなくなるわけである。

  しかし、管理の容易さから形式１を奨励する。つまり効果音専用の

ＭＩＤＩチャンネルを取っておいてこのチャンネルを用いて効果音を鳴らすようにする

わけである。


●ＡＤＰＣＭ音の効果音

  ＡＤＰＣＭはＰＣＭ８．Ｘモードでない時は単音であるため形式２のみ有効である。

  ＦＭ音源とＡＤＰＣＭが連続するようなチャンネルアサイン構造にしておいて、

ＦＭ音源とＡＤＰＣＭ音源を両方使った効果音というのも演奏できる。

  また、複雑なものでないワン・ショットのＡＤＰＣＭの効果音の演奏ならば専用の

ファンクション・コール(ファンクション$13とファンクション$14)が設けてあるので、

それらを用いた方が高速応答が実現できる。

  リスト１２にその一例を示す。

まず、リスト中のADPCM_se_play1を見てほしい。これは任意のアドレスに格納されて

いるＡＤＰＣＭデータをファンクションコール$13を使って、ＢＧＭに割り込ませて

鳴らすためのサブルーチンである。ＢＧＭ側でＡＤＰＣＭをドラム等で使用している

場合はそれを一時停止して効果音を演奏する。効果音が鳴り終ると自動的にＢＧＭの

演奏にもどる。

  ADPCM_se_play1ではアドレスに配置されたＡＤＰＣＭデータに便宜的に番号をつけ、

呼び出す時にはd0.lにその番号を代入して呼び出すようになっている。その後ろにある

adr_frq_tblは各効果音ＡＤＰＣＭデータのサイズ、優先レベル(囲み参照)、

データの開始アドレスの管理テーブルである。

  ADPCM_se_play2はＺＭＵＳＩＣにすでにＺＰＤデータ等によって登録済みの

ＡＤＰＣＭ音を効果音で鳴らすためのサブルーチンである。ファンクションコール$14

をそのまま使っただけの単純なものである。d0.lに指定する効果音番号は

ＡＤＰＣＭコンフィギュレーションで設定したノートナンバーに相当する。例えば

コンフィギュレーションで

12＝bomb.pcm

のように書き、これをＺＰＤとしてＺＭＵＳＩＣに登録してあれば、このbomb.pcmを

効果音で鳴らすには、d0.lに12を入れればよい。

  後ろについているfrq_pan_tblというテーブルはADPCM_se_play1のadr_frq_tblから

データサイズとデータアドレスを取り去ったような書式をしている。



┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃                         ＡＤＰＣＭ効果音の優先レベル                     ┃
┃                                                                          ┃
┃                                                                          ┃
┃  Ｘ６８ｋのＡＤＰＣＭは(ＰＣＭ８独立チャンネルモード時を除いては)単声    ┃
┃                                                                          ┃
┃です。ですから、効果音の発音要求は基本的に後着優先、つまり新しく発音要求  ┃
┃                                                                          ┃
┃されたものが発音されることになっています。しかし、ゲームなどで面と面との  ┃
┃                                                                          ┃
┃繋ぎのイベントの音声メッセージなど、どうしても爆発音などでかき消されたく  ┃
┃                                                                          ┃
┃ない場合があります。そこでＺＭＵＳＩＣでは非ＰＣＭ８モードでは効果音を    ┃
┃                                                                          ┃
┃発音させる時に優先レベルというものを設定可能になっています。優先レベルは  ┃
┃                                                                          ┃
┃０～２５５まで設定可能ですが実用上は０，１程度で十分でしょう。            ┃
┃                                                                          ┃
┃  以下に優先レベルの例を示します。                                        ┃
┃                                                                          ┃
┃                                                                          ┃
┃  ┌─────────┬──────────┬───────┐            ┃
┃  │発音中の優先レベル│発音要求の優先レベル│     結果     │            ┃
┃  ├─────────┼──────────┼───────┤            ┃
┃  │       0          │        0           │ 発音要求採択 │            ┃
┃  │       0          │        1           │ 発音要求採択 │            ┃
┃  │       1          │        0           │ 発音要求却下 │            ┃
┃  │       1          │        1           │ 発音要求採択 │            ┃
┃  └─────────┴──────────┴───────┘            ┃
┃                                                                          ┃
┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛


１４．２．  映像との同期


  ＺＭＵＳＩＣには映像と音楽演奏を同期させるためのファンクションコールや

機能が装備されている。ここではこの機能について解説を行う。


１４．２．１．  ファンクションコール$43を用いる


  ファンクション$43で映像同期モードをオンにしてから演奏を開始すると、

演奏開始からある時点までの絶対音長の合計値が演奏トラックワーク

	p_total(.l)       $3C

に格納されていく。これをユーザープログラム側で監視すれば、曲に合わせて画面等を

切り換えることが出来る（例えばオーケストラヒットが鳴るたびに絵を換えるなど）。

  ちなみにワークp_totalの増加には以下の規則がある。

１．p_total()はＭＭＬの[do]命令で初期化される。また、この時点までの

    p_totalの値を

	p_total_olp       $C6

    へ退避する。

２．p_totalは同期モードオンを行った時にのみ初期化される。'm_init()'命令、

    (Ｉ)命令、ファンクション$00などでは初期化されない。

３．p_totalは同期モードオンを行った時から値に意味を持ち始める。

  具体的な使用プロセスは以下のようになる。

１．ファンクション$43で同期モードをオンにする。

２．曲の演奏を開始する。

３．演奏トラックワークp_totalを参照し(MEASURE13参照)、狙った

    タイミングになるまで待つ。

４．狙ったタイミングになったならその仕事をする。

５．やりたいことが全て終わったらファンクション$43で同期モードをオフにする。


  演奏データのトラック１が４小節演奏されたら(合計ステップタイムにして192×4＝768)
次の処理をするようなサンプルを以下に示す。

┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃Z_MUSIC macro   func    *ドライバへのファンクションコール・マクロ   ┃
┃        moveq.l func,d1                                             ┃
┃        trap    #3                                                  ┃
┃        endm                                                        ┃
┃                                                                    ┃
┃        moveq.l #1,d2   *トラック番号＝1                            ┃
┃        Z_MUSIC #$3c    *a0＝トラック１の演奏トラックワークの       ┃
┃                        *先頭アドレス                               ┃
┃wait_lp:                *４小節演奏するまでループ                   ┃
┃        cmpi.l  #768,p_total(a0)                                    ┃
┃        bcs     wait_lp                                             ┃
┃        *次の処理へ                                                 ┃
┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛


１４．２．２．  ユーザー開放ワークを使用する


  演奏トラックワークの

	p_user(.b)        $ff

は、ユーザーが自由に使用してよいワークとされている。これに対してＭＭＬの

ワーク直接書き替えコマンド

？a,d       a:ワークオフセット(0～255)  d:データ(0～255)

を用いて書き込みを行い監視プログラムとの通信を行い、映像の同期を行うことが

できる。このp_userは'm_init()'命令、(Ｉ)命令、ファンクション$00などでは初期化

されず、値は不安定となるので、演奏データの冒頭でこれを初期化する必要がある。

  具体的な使用プロセスは

１．演奏データは曲の先頭で

    ?$ff,0  (書き込む値は0でなくてもよい)

    を実行してp_userを初期化する。

２．ユーザープログラム側でp_userを監視し、希望の値が書き込まれるまで待つ。

３．演奏データは(目的のタイミングで)

    ?$ff,1  (書き込む値は1でなくてもよい)

    を実行し、監視プログラム側につぎの指示を促す。


  以下に演奏データのトラック１が、p_userに０以外の値を書き込むまで待ち、
書き込みを確認後、次の処理へ移る、というようなサンプルを示す。
┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃(i)                                                         ┃
┃(m1,1000)(a1,1)                                             ┃
┃(t1)@1 o4 q8 v15 L4 ?$ff,0 cdef gab<c ?$ff,1 cdef gab<c     ┃
┃(p)                  ↑p_user_初期化    ↑p_userマーク      ┃
┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃Z_MUSIC macro   func    *ドライバへのファンクションコール・マクロ   ┃
┃        moveq.l func,d1                                             ┃
┃        trap    #3                                                  ┃
┃        endm                                                        ┃
┃                                                                    ┃
┃        moveq.l #1,d2   *トラック番号＝1                            ┃
┃        Z_MUSIC #$3c    *a0＝トラック１の演奏トラックワークの       ┃
┃                        *先頭アドレス                               ┃
┃wait_lp:                *p_userが0以外になるまでループ              ┃
┃        tst.b   p_user(a0)                                          ┃
┃        beq     wait_lp                                             ┃
┃        *次の処理へ                                                 ┃
┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
